//环形链表
//leetcode链接：https://leetcode.cn/problems/linked-list-cycle-ii/
struct ListNode *detectCycle(struct ListNode *head)   //输入head=[3,2,0,4] pos=1(环开始的位置)  索引从0开始 pos如果为-1那么表示没有环
{
	ListNode* fast, * slow;
	fast = head;
	slow = head;
	//利用快慢指针是否会相遇判断是否存在环
	while (fast && fast->next != NULL)
	{
		fast = fast->next->next; //假设x为头节点到入环口的节点数，y为入环口到最初相遇位置的节点个数，z为该位置到入环口的节点个数，则有2(x+y)=x+y+n(z+y),即x=nz+(n-1)y (其中n>=1)
		if (fast == slow) //1.判断有环 2.确定相遇位置
		{
			ListNode* index1, * index2,*pos;
			index1 = fast;
			index2 = head;
			while (index1 != index2)
			{
				index1 = index1->next;   //三者的关系为x=(n-1)(y+z)+z 其中y+z=一圈的节点个数，所以当最后一圈时有x-(n-1)圈=z,只要二者共速就可以相遇
				index2 = index2->next;
			}
			pos = index1;
			return pos;  //返回入环口
		}
	}
	//没有环的情况
	return NULL;
}
#include<string>
//有效字母异位词
bool isAnagram(char* s, char* t) 
{
	int hash[26] = { 0 };
	int s_size=0,t_size=0;
	int i, j;
	s_size = strlen(s);
	t_size = strlen(t);
	for (i = 0; i < s_size; i++)
	{
		hash[s[i] - 'a']++;
	}
	for (j = 0; j < t_size; j++)
	{
		hash[t[j] - 'a']--;
	}
	for (int n = 0; n < 26; n++)
	{
		if (hash[n] != 0)
			return false;
	}
	return true;
}
